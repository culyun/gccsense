#!/usr/bin/env ruby

require 'pathname'
require 'shellwords'
require 'stringio'

class GCCRec
  def initialize(args)
    @args = args.dup
    @cwd = Dir.getwd
    @cc_args = []
    @comp_args = args.dup
    @input_files = []
  end

  def process
    parse_own_args
    if @replay
      replay
    else
      parse_gcc_args
      record
      compile
    end
  end

  def parse_own_args
    @driver = File.basename($0)
    if @driver == 'gccrec'
      @driver = nil
      while arg = @args.shift
        case arg
        when '-Q'
          @quick = true
        when '-d'
          @db = @args.shift
        when '-f'
          @input_file = @args.shift
        when '-p'
          @prefix = @args.shift
        when '-r'
          @replay = true
        when '-v'
          @verbose = true
        when /^-/
          $stderr.puts "unknown option: #{arg}"
        else
          if @replay
            unless @db
              path = Pathname.new(arg)
              until path.root?
                parent = path.parent
                db = parent + '.gccrec'
                if db.file?
                  @db = db.realpath.to_s rescue nil
                  break
                end
                path = parent
              end
            end
            @input_files << arg
          else
            @driver = arg
          end
          @comp_args = @args.dup
          break
        end
      end
      if !@driver and !@replay
        $stderr.puts 'driver not given'
        exit 1
      end
    end
    @db = "#{ENV['HOME']}/.gccrec" unless @db
  end

  def replay
    @input_files.each do |file|
      cmd = lookup((Pathname.new(file).realpath.to_s rescue nil))
      if cmd
        Dir.chdir(cmd['cwd']) {
          program = cmd['program']
          args = shellwords(cmd['args'])
          if @prefix
            args.unshift program
            program = @prefix
          end
          array = [program] + args + @comp_args + [@input_file || cmd['file']]
          puts array.join(' ') if @verbose
          unless system(*array)
            exit $?
          end
        }
      else
        $stderr.puts "record not found: #{file}"
      end
    end
  end

  def parse_gcc_args
    until @args.empty?
      arg = @args.shift
      case arg
      when /^-(?:o|I|idirafter|imacros|include|iprefix|isystem|iwithprefix|iwithprefixbefore|L|D|U|x|MF|MT|MQ|aux-info|-param|A|Xlinker|u)(.*)$/
        @cc_args << arg
        @cc_args << @args.shift if $1.empty?
      when /^-/
        @cc_args << arg
      else
        # heuristic
        if File.file?(arg) and !File.extname(arg).empty?
          @input_files << arg
        else
          @cc_args << arg
        end
      end
    end
  end

  def compile
    array = [@driver] + @comp_args
    puts array.join(' ') if @verbose
    exec(*array) unless @dry_run
  end

  def record
    @input_files.each do |file|
      path = Pathname.new(file).realpath rescue nil
      if path
        append(path.to_s, {'program' => @driver, 'args' => unshellwords(@cc_args), 'file' => file, 'cwd' => @cwd})
      end
    end
  end

  def lookup(path)
    cmd = nil
    File.open(@db) do |f|
      while l = f.gets
        l.chomp!
        case l
        when /^$/
        when "#{path}"
          cmd = {}
          while l = f.gets
            l.chomp!
            case l
            when /^([^=]+?)=(.*)$/
              cmd[$1] = $2
            else
              break
            end
          end
        end
      end
    end rescue nil
    cmd
  end

  def append(path, cmd)
    oldcmd = lookup(path)
    return if cmd.eql?(oldcmd)
    
    File.open(@db, 'a') do |f|
      f.puts "#{path}"
      cmd.each {|k, v| f.puts "#{k}=#{v}"}
      f.puts
    end
  end

  def shellwords(string)
    Shellwords.shellwords string
  end

  def unshellwords(array)
    str = StringIO.new
    sep = ''
    array.each do |elt|
      str << sep
      sep = ' '
      if elt.index(/\s/)
        str << '"'
        str << elt.gsub(/"/, /\\"/)
        str << '"'
      else
        str << elt
      end
    end
    str.string
  end
end

GCCRec.new(ARGV).process
