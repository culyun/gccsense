#!/usr/bin/env ruby

require 'pathname'
require 'stringio'
require 'digest/md5'
require 'fileutils'

class AutoPCH
  ARG1_REGEXP = /^-(?:I|idirafter|imacros|include|iprefix|isystem|iwithprefix|iwithprefixbefore|L|D|U|x|MF|MT|MQ|aux-info|-param|A|Xlinker|u)(.*)$/
  PCH_SKIP_ARG_REGEXP = /^-(?:fsyntax-only|code-completion-at)/
  PCH_SKIP_ARG1_REGEXP = /^-(?:o)(.*)$/

  class PPDirectiveReader
    def initialize(path)
      @path = path
      @file = File.open(path, 'rb');
    end

    def close
      @file.close
    end

    def read_directive
      dir = read_nonblank_code_line
      return nil unless dir =~ /^\s*#/

      # handle backslashes
      l = dir
      dir << l while l =~ /\\\s*$/ and l = read_code_line

      dir
    end

    def read_code_line
      l = @file.gets

      # skip comments
      while l and start = l.index(/\/[\/*]/)
        if $& == '//'         # c++ style comment
          l = l[0, start]
        else                  # c style comment
          pos = start
          while !(last = l.index('*/', pos)) and r = @file.gets
            pos = l.length
            l << r
          end
          l[start, last + 2] = ' ' if last
        end
      end

      l
    end

    def read_nonblank_code_line
      while l = read_code_line
        return l unless l =~ /^\s*$/
      end
    end
  end

  class DependencyFile
    attr_reader :dependencies

    def initialize(path)
      dep = File.read(path)
      start = dep.index(':')
      @dependencies = start ? dep[start + 2..dep.length].split(/[\s\\]+/) : []
      @dependencies.shift
    end
  end

  def initialize(args)
    prepare
    parse_args args
  end

  def prepare
    @cwd = Dir.getwd
    @tmp_dir = ENV['TMPDIR'] || ENV['TMP'] || ENV['TEMP'] || '/tmp'
    @cache_dir = "#{ENV['HOME']}/.autopch"
    Dir.mkdir @cache_dir unless File.exists? @cache_dir
  end

  def parse_args(args)
    @driver = File.basename($0)
    @args = args.dup
    return if args.empty?

    i = 0
    if @driver == 'autopch'
      i = 1
      @driver = args[0]
      @args.shift
    end

    @cc_args = []
    @pch_args = []
    @pch_lang = @driver =~ /g\+\+/ ? 'c++-header' : 'c-header'
    @input_files = []

    while i < args.length
      arg = args[i]
      case arg
      when '-c'
        @c_opt_given = true
        @cc_args << arg
      when ARG1_REGEXP
        @cc_args << arg
        @pch_args << arg
        if $1.empty?
          i += 1
          @cc_args << args[i]
          @pch_args << args[i]
        end
      when PCH_SKIP_ARG_REGEXP
        @cc_args << arg
      when PCH_SKIP_ARG1_REGEXP
        @cc_args << arg
        @cc_args << args[i += 1] if $1.empty?
      when /^-/
        @cc_args << arg
        @pch_args << arg
      else
        @input_files << arg
      end
      i += 1
    end
  end

  def process
    if valid_args?
      compile_all
    else
      fallback
    end
  end

  def valid_args?
    @input_files and !@input_files.empty? and @c_opt_given
  end

  def compile_all
    @input_files.each do |file|
      h = make_pch(file)
      compile(file, h)
    end
  end

  def fallback
    exec(@driver, *@args)
  end

  def compile(file, h)
    args = h ? ['-include', h] : []
    args += @cc_args + ['-I', @cwd, file]
    system(@driver, *args)
  end

  def make_pch(input_file)
    path = path_absolutize(input_file)
    return unless path

    header = read_header(path)
    return if header =~ /\A\s*\z/ # no worth to make pch

    digest = make_header_digest(path, header)
    dep = cache_path(dep_name(digest))

    if file_exists? dep
      dep_digest = make_dependency_digest(dep)
      h = cache_path(h_name(dep_digest))
      pch = cache_path(pch_name(dep_digest))
    end

    if file_exists? h, pch, dep
      # LRU cache
      now = Time.now
      File.utime(now, now, h, pch, dep)
    else
      h, pch = compile_header(header, dep)
    end

    h
  end

  def path_absolutize(path)
    Pathname.new(path).realpath.to_s rescue nil
  end

  def read_header(path)
    return slurp_until_first_c_token(path)
  end

  def make_header_digest(path, header)
    src = StringIO.new
    src << @cwd
    src << @driver
    src << path
    src << @pch_args.join(' ')
    src << header
    Digest::MD5.hexdigest(src.string)
  end

  def make_dependency_digest(dep)
    deps = DependencyFile.new(dep).dependencies
    src = StringIO.new
    deps.each do |file|
      if File.exists? file
        src << file
        src << File.mtime(file).to_i
      end
    end
    Digest::MD5.hexdigest(src.string)
  end

  def h_name(base) "#{base}.h" end

  def pch_name(base) "#{h_name(base)}.gch" end

  def dep_name(base) "#{base}.dep" end

  def cache_path(name) "#{@cache_dir}/#{name}" end

  def file_exists?(*files)
    files.all? {|file| file and File.exists?(file)}
  end

  def compile_header(header, dep)
    tmp_h = "#{@tmp_dir}/autopch.h"
    tmp_pch = "#{@tmp_dir}/autopch.h.gch"

    # write header contents
    File.open(tmp_h, 'wb') {|f| f.write(header)}

    # generate dependency file
    args = @pch_args + ['-I', @cwd, '-MM', '-MF', dep, tmp_h]
    system(@driver, *args)

    # compile header
    args = @pch_args + ['-I', @cwd, '-x', @pch_lang, tmp_h]
    system(@driver, *args)

    if file_exists? dep, tmp_h, tmp_pch
      # succeed
      dep_digest = make_dependency_digest(dep)
      h = cache_path(h_name(dep_digest))
      pch = cache_path(pch_name(dep_digest))

      FileUtils.cp tmp_h, h
      FileUtils.cp tmp_pch, pch
    end

    [h, pch]
  end
  
  def slurp_until_first_c_token(path)
    reader = PPDirectiveReader.new(path)

    i = 0
    dirs = []
    cond_start = nil
    cond_depth = 0
    while dir = reader.read_directive
      name, value = (dir =~ /^\s*#([^\s]*)(?:\s+([^\s]*))/) && $1, $2
      break if name == 'pragma' and value == 'hdrstop'

      case name
      when 'if', 'ifdef'
        unless cond_start
          cond_start = i
          cond_depth = 0
        end
        cond_depth += 1
      when 'endif'
        if cond_start
          cond_depth -= 1
          cond_start = nil if cond_depth == 0
        end
      end

      dirs << dir
      i += 1
    end
    reader.close

    dirs[cond_start..dirs.length] = [] if cond_start
    dirs.join "\n"
  end
end

AutoPCH.new(ARGV).process
